#!/usr/bin/env python3
# coding=utf-8

opll_instruments = [
	# OPLL (YM2413)
	# April 2015 David Viens, tweaked May 19-21th 2015 Hubert Lamontagne
	0x71, 0x61, 0x1E, 0x17, 0xEF, 0x7F, 0x00, 0x17, #Violin	
	0x13, 0x41, 0x1A, 0x0D, 0xF8, 0xF7, 0x23, 0x13, #Guitar
	0x13, 0x01, 0x99, 0x00, 0xF2, 0xC4, 0x11, 0x23, #Piano
	0x31, 0x61, 0x0E, 0x07, 0x98, 0x64, 0x70, 0x27, #Flute
	0x22, 0x21, 0x1E, 0x06, 0xBF, 0x76, 0x00, 0x28, #Clarinet
	0x31, 0x22, 0x16, 0x05, 0xE0, 0x71, 0x0F, 0x18, #Oboe
	0x21, 0x61, 0x1D, 0x07, 0x82, 0x8F, 0x10, 0x07, #Trumpet
	0x23, 0x21, 0x2D, 0x14, 0xFF, 0x7F, 0x00, 0x07, #Organ
	0x41, 0x61, 0x1B, 0x06, 0x64, 0x65, 0x10, 0x17, #Horn
	0x61, 0x61, 0x0B, 0x18, 0x85, 0xFF, 0x81, 0x07, #Synthesizer
	0x13, 0x01, 0x83, 0x11, 0xFA, 0xE4, 0x10, 0x04, #Harpsichord
	0x17, 0x81, 0x23, 0x07, 0xF8, 0xF8, 0x22, 0x12, #Vibraphone
	0x61, 0x50, 0x0C, 0x05, 0xF2, 0xF5, 0x29, 0x42, #Synthesizer Bass
	0x01, 0x01, 0x54, 0x03, 0xC3, 0x92, 0x03, 0x02, #Acoustic Bass
	0x41, 0x41, 0x89, 0x03, 0xF1, 0xE5, 0x11, 0x13, #Electric Guitar

	# OPLL-X (YM2423)
	# May 4-6 2016 Hubert Lamontagne
	# Doesn't seem to have any diff between opllx-x and opllx-y
	# Drums seem identical to regular opll
	0x61, 0x61, 0x1B, 0x07, 0x94, 0x5F, 0x10, 0x06, #1	Strings	Saw wave with vibrato Violin
	0x93, 0xB1, 0x51, 0x04, 0xF3, 0xF2, 0x70, 0xFB, #2	Guitar	Jazz GuitarPiano
	0x41, 0x21, 0x11, 0x85, 0xF2, 0xF2, 0x70, 0x75, #3	Electric Guitar	Same as OPLL No.15 Synth 
	0x93, 0xB2, 0x28, 0x07, 0xF3, 0xF2, 0x70, 0xB4, #4	Electric Piano 2	Slow attack, tremoloDing-a-ling
	0x72, 0x31, 0x97, 0x05, 0x51, 0x6F, 0x60, 0x09, #5 	Flute	Same as OPLL No.4Clarinet
	0x13, 0x30, 0x18, 0x06, 0xF7, 0xF4, 0x50, 0x85, #6	Marimba 	Also be used as steel drumXyophone
	0x51, 0x31, 0x1C, 0x07, 0x51, 0x71, 0x20, 0x26, #7	Trumpet 	Same as OPLL No.7Trumpet
	0x41, 0xF4, 0x1B, 0x07, 0x74, 0x34, 0x00, 0x06, #8	Harmonica Harmonica synth
	0x50, 0x30, 0x4D, 0x03, 0x42, 0x65, 0x20, 0x06, #9	Tuba Tuba
	0x40, 0x20, 0x10, 0x85, 0xF3, 0xF5, 0x20, 0x04, #10 	Synth Brass 2 Synth sweep
	0x61, 0x61, 0x1B, 0x07, 0xC5, 0x96, 0xF3, 0xF6, #11 	Short Saw	Saw wave with short envelopeSynth hit
	0xF9, 0xF1, 0xDC, 0x00, 0xF5, 0xF3, 0x77, 0xF2, #12 	Vibraphone	Bright vibraphoneVibes
	0x60, 0xA2, 0x91, 0x03, 0x94, 0xC1, 0xF7, 0xF7, #13 	Electric Guitar 2	Clean guitar with feedbackHarmonic bass
	0x30, 0x30, 0x17, 0x06, 0xF3, 0xF1, 0xB7, 0xFC, #14 	Synth Bass 2Snappy bass
	0x31, 0x36, 0x0D, 0x05, 0xF2, 0xF4, 0x27, 0x9C, #15 	Sitar	Also be used as ShamisenBanjo

	# OPLL-P (YMF281)
	# May 14th 2015 Hubert Lamontagne
	0x72, 0x21, 0x1A, 0x07, 0xF6, 0x64, 0x01, 0x16, # Clarinet ~~ Electric String 	Square wave with vibrato
	0x00, 0x10, 0x45, 0x00, 0xF6, 0x83, 0x73, 0x63, # Synth Bass ~~ Bow wow 	Triangular wave
	0x13, 0x01, 0x96, 0x00, 0xF1, 0xF4, 0x31, 0x23, # Piano ~~ Electric Guitar 	Despite of its name, same as Piano of YM2413.
	0x71, 0x21, 0x0B, 0x0F, 0xF9, 0x64, 0x70, 0x17, # Flute ~~ Organ 	Sine wave 
	0x02, 0x21, 0x1E, 0x06, 0xF9, 0x76, 0x00, 0x28, # Square Wave ~~ Clarinet 	Same as ones of YM2413. 
	0x00, 0x61, 0x82, 0x0E, 0xF9, 0x61, 0x20, 0x27, # Space Oboe ~~ Saxophone 	Saw wave with vibrato 
	0x21, 0x61, 0x1B, 0x07, 0x84, 0x8F, 0x10, 0x07, # Trumpet ~~ Trumpet 	Same as ones of YM2413. 
	0x37, 0x32, 0xCA, 0x02, 0x66, 0x64, 0x47, 0x29, # Wow Bell ~~ Street Organ 	Calliope 
	0x41, 0x41, 0x07, 0x03, 0xF5, 0x70, 0x51, 0xF5, # Electric Guitar ~~ Synth Brass 	Same as Synthesizer of YM2413. 
	0x36, 0x01, 0x5E, 0x07, 0xF2, 0xF3, 0xF7, 0xF7, # Vibes ~~ Electric Piano 	Simulate of Rhodes Piano 
	0x00, 0x00, 0x18, 0x06, 0xC5, 0xF3, 0x20, 0xF2, # Bass ~~ Bass 	Electric bass 
	0x17, 0x81, 0x25, 0x07, 0xF7, 0xF3, 0x21, 0xF7, # Vibraphone ~~ Vibraphone	Same as ones of YM2413.
	0x35, 0x64, 0x00, 0x00, 0xFF, 0xF3, 0x77, 0xF5, # Vibrato Bell ~~ Chime 	Bell 
	0x11, 0x31, 0x00, 0x07, 0xDD, 0xF3, 0xFF, 0xFB, # Click Sine ~~ Tom Tom II 	Tom 
	0x3A, 0x21, 0x00, 0x07, 0x95, 0x84, 0x0F, 0xF5, # Noise and Tone ~~ Noise 	for S.E. 

	# VRC7
	# May 15th 2015 Hubert Lamontagne & David Viens
	0x03, 0x21, 0x05, 0x06, 0xC8, 0x81, 0x42, 0x27, # Buzzy Bell
	0x13, 0x41, 0x14, 0x0D, 0xF8, 0xF7, 0x23, 0x12, # Guitar
	0x31, 0x11, 0x08, 0x08, 0xFA, 0xC2, 0x28, 0x22, # Wurly
	0x31, 0x61, 0x0C, 0x07, 0xF8, 0x64, 0x60, 0x27, # Flute
	0x22, 0x21, 0x1E, 0x06, 0xFF, 0x76, 0x00, 0x28, # Clarinet
	0x02, 0x01, 0x05, 0x00, 0xAC, 0xF2, 0x03, 0x02, # Synth
	0x21, 0x61, 0x1D, 0x07, 0x82, 0x8F, 0x10, 0x07, # Trumpet
	0x23, 0x21, 0x22, 0x17, 0xFF, 0x73, 0x00, 0x17, # Organ
	0x15, 0x11, 0x25, 0x00, 0x41, 0x71, 0x00, 0xF1, # Bells
	0x95, 0x01, 0x10, 0x0F, 0xB8, 0xAA, 0x50, 0x02, # Vibes
	0x17, 0xC1, 0x5E, 0x07, 0xFA, 0xF8, 0x22, 0x12, # Vibraphone
	0x71, 0x23, 0x11, 0x06, 0x65, 0x74, 0x10, 0x16, # Tutti
	0x01, 0x02, 0xD3, 0x05, 0xF3, 0x92, 0x83, 0xF2, # Fretless
	0x61, 0x63, 0x0C, 0x00, 0xA4, 0xFF, 0x30, 0x06, # Synth Bass
	0x21, 0x62, 0x0D, 0x00, 0xA1, 0xFF, 0x50, 0x08, # Sweep
]

def convert_opll_to_ikaopll(instruments):
	"""OPLL音色データをIKAOPLL 63bitフォーマットに変換"""
	results = []
	
	# 8バイトずつ処理
	for i in range(0, len(instruments), 8):
		if i + 8 > len(instruments):
			break
		
		# 8バイト取得
		data = instruments[i:i+8]
		
		# モジュレーター(M)のデータ: インデックス 0, 2, 4, 6
		# キャリア(C)のデータ: インデックス 1, 3, 5, 7
		
		# data[0], data[1]: bit3~0=MULTI, bit4=KSR, bit5=EGTYP, bit6=VIB, bit7=AM
		MULTI_M = data[0] & 0x0F
		KSR_M = (data[0] >> 4) & 0x01
		EGTYP_M = (data[0] >> 5) & 0x01
		VIB_M = (data[0] >> 6) & 0x01
		AM_M = (data[0] >> 7) & 0x01
		
		MULTI_C = data[1] & 0x0F
		KSR_C = (data[1] >> 4) & 0x01
		EGTYP_C = (data[1] >> 5) & 0x01
		VIB_C = (data[1] >> 6) & 0x01
		AM_C = (data[1] >> 7) & 0x01
		
		# data[2]: bit5~0=TL, bit7~6=KSL (M用)
		TL = data[2] & 0x3F
		KSL_M = (data[2] >> 6) & 0x03
		
		# data[3]: bit2~0=FB, bit3=DM, bit4=DC, bit7~6=KSL (C用)
		FB = data[3] & 0x07
		DM = (data[3] >> 3) & 0x01
		DC = (data[3] >> 4) & 0x01
		KSL_C = (data[3] >> 6) & 0x03
		
		# data[4], data[5]: bit3~0=DR, bit7~4=AR
		DR_M = data[4] & 0x0F
		AR_M = (data[4] >> 4) & 0x0F
		
		DR_C = data[5] & 0x0F
		AR_C = (data[5] >> 4) & 0x0F
		
		# data[6], data[7]: bit3~0=RR, bit7~4=SL
		RR_M = data[6] & 0x0F
		SL_M = (data[6] >> 4) & 0x0F
		
		RR_C = data[7] & 0x0F
		SL_C = (data[7] >> 4) & 0x0F
		
		# 63bitの値を構築
		value = 0
		value |= (RR_C & 0x0F) << 0      # bit3~0
		value |= (RR_M & 0x0F) << 4      # bit7~4
		value |= (SL_C & 0x0F) << 8      # bit11~8
		value |= (SL_M & 0x0F) << 12     # bit15~12
		value |= (DR_C & 0x0F) << 16     # bit19~16
		value |= (DR_M & 0x0F) << 20     # bit23~20
		value |= (AR_C & 0x0F) << 24     # bit27~24
		value |= (AR_M & 0x0F) << 28     # bit31~28
		value |= (KSL_C & 0x03) << 32    # bit33~32
		value |= (KSL_M & 0x03) << 34    # bit35~34
		value |= (MULTI_C & 0x0F) << 36  # bit39~36
		value |= (MULTI_M & 0x0F) << 40  # bit43~40
		value |= (KSR_C & 0x01) << 44    # bit44
		value |= (KSR_M & 0x01) << 45    # bit45
		value |= (EGTYP_C & 0x01) << 46  # bit46
		value |= (EGTYP_M & 0x01) << 47  # bit47
		value |= (VIB_C & 0x01) << 48    # bit48 (PM)
		value |= (VIB_M & 0x01) << 49    # bit49 (PM)
		value |= (AM_C & 0x01) << 50     # bit50
		value |= (AM_M & 0x01) << 51     # bit51
		value |= (FB & 0x07) << 52       # bit54~52
		value |= (DM & 0x01) << 55       # bit55
		value |= (DC & 0x01) << 56       # bit56
		value |= (TL & 0x3F) << 57       # bit62~57
		
		# 63bitの2進数文字列に変換
		bin_str = format(value, '063b')
		
		# アンダースコアを挿入 (MSBから: TL_DC_DM_FB_AM_PM_ET_KSR_MULTI_KSL_AR_DR_SL_RR)
		formatted = (
			bin_str[0:6] + '_' +      # TL (6bit)
			bin_str[6:7] + '_' +      # DC (1bit)
			bin_str[7:8] + '_' +      # DM (1bit)
			bin_str[8:11] + '_' +     # FB (3bit)
			bin_str[11:13] + '_' +    # AM(M), AM(C) (2bit)
			bin_str[13:15] + '_' +    # PM(M), PM(C) (2bit)
			bin_str[15:17] + '_' +    # ET(M), ET(C) (2bit)
			bin_str[17:19] + '_' +    # KSR(M), KSR(C) (2bit)
			bin_str[19:23] + '_' +    # MULTI(M) (4bit)
			bin_str[23:27] + '_' +    # MULTI(C) (4bit)
			bin_str[27:29] + '_' +    # KSL(M) (2bit)
			bin_str[29:31] + '_' +    # KSL(C) (2bit)
			bin_str[31:35] + '_' +    # AR(M) (4bit)
			bin_str[35:39] + '_' +    # AR(C) (4bit)
			bin_str[39:43] + '_' +    # DR(M) (4bit)
			bin_str[43:47] + '_' +    # DR(C) (4bit)
			bin_str[47:51] + '_' +    # SL(M) (4bit)
			bin_str[51:55] + '_' +    # SL(C) (4bit)
			bin_str[55:59] + '_' +    # RR(M) (4bit)
			bin_str[59:63]            # RR(C) (4bit)
		)
		
		results.append(f": mem_q <= 63'b{formatted};")
	
	return results

# 変換実行
if __name__ == '__main__':
	output_lines = convert_opll_to_ikaopll(opll_instruments)
	
	# output.txt に書き出し
	with open('output.txt', 'w', encoding='utf-8') as f:
		for line in output_lines:
			f.write(line + '\n')
	
	print(f"変換完了: {len(output_lines)} 個の音色データを output.txt に出力しました。")
